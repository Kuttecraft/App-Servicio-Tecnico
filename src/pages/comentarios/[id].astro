---
/**
 * P√°gina de comentarios de un ticket.
 *
 * üìù Qu√© muestra:
 * - Cabecera con el n√∫mero de ticket y el nombre del cliente.
 * - Historial de comentarios en orden descendente (m√°s reciente arriba).
 * - Cantidad total de comentarios.
 *
 * ‚úç Interacci√≥n:
 * - Si el usuario logueado es admin o t√©cnico:
 *    ‚Ä¢ aparece un formulario para agregar un comentario nuevo.
 *    ‚Ä¢ el comentario se env√≠a v√≠a fetch POST a /api/agregarComentario.
 *    ‚Ä¢ se actualiza la UI en el momento (optimistic UI), sin recargar.
 *
 * üîê Permisos:
 * - S√≥lo admin o t√©cnico ven y usan el formulario.
 * - Usuarios sin permiso igualmente ven la lista de comentarios.
 *
 * üß± Tablas usadas (v√≠a Supabase en el lado servidor Astro):
 *   - tickets_mian
 *   - cliente (join de tickets_mian.cliente_id)
 *   - ticket_comentarios (historial)
 *   - tecnicos / autor_id (para mostrar "Nombre Apellido")
 *
 * üîÑ Nota sobre joins:
 * - Supabase a veces devuelve relaciones como objeto o como array con un √∫nico objeto.
 *   Por eso hay helpers como getAutorNombre() y getClienteNombre() que toleran ambos formatos.
 */

import BasePrivateLayout from '../../layouts/BasePrivateLayout.astro';
import { supabase } from '../../lib/supabase';

// ======================================================================
// 1Ô∏è‚É£ Par√°metros y perfil del usuario
// ======================================================================

// Tomamos el :id de la URL din√°mica (por ej. /comentarios/123 -> id="123")
const { id } = Astro.params as { id: string };

// Perfil/rol del usuario logueado (inyectado en Astro.locals por middleware auth)
type Perfil = { rol?: string; admin?: boolean; activo?: boolean };
const perfil = (Astro.locals as any).perfil as Perfil | undefined;

// Determinamos permisos:
const isAdmin = (perfil?.rol === 'admin') || (perfil?.admin === true);
const isTecnico = perfil?.rol === 'tecnico';

// ======================================================================
// 2Ô∏è‚É£ Fetch de datos necesarios para renderizar la p√°gina SSR
// ======================================================================

// 2.1 Traer datos b√°sicos del ticket para la cabecera:
//     - ticket (n√∫mero de ticket visible al usuario)
//     - estado
//     - cliente (nombre comercial / etiqueta)
//     Nota: usamos alias "cliente:cliente_id" para hacer el join
const { data: ticket } = await supabase
  .from('tickets_mian')
  .select(`
    id,
    ticket,
    estado,
    cliente:cliente_id ( cliente )
  `)
  .eq('id', id)
  .maybeSingle();

// 2.2 Traer los comentarios del ticket ordenados DESC por fecha de creaci√≥n.
//     Tambi√©n pedimos count:'exact' para mostrar el total.
//     Cada comentario incluye:
//       - mensaje (texto / HTML controlado)
//       - creado_en (timestamp)
//       - autor (nombre, apellido) -> viene de autor_id join
const { data: comentarios, count: totalComentarios } = await supabase
  .from('ticket_comentarios')
  .select(`
    id,
    mensaje,
    creado_en,
    autor:autor_id ( nombre, apellido )
  `, { count: 'exact' })
  .eq('ticket_id', id)
  .order('creado_en', { ascending: false });

// ======================================================================
// 3Ô∏è‚É£ Helpers de presentaci√≥n (solo del lado servidor en Astro)
// ======================================================================

/**
 * fechaHoraAR(iso):
 * - Convierte un string ISO de fecha a formato local "es-AR" con fecha y hora 24hs.
 * - Si no hay valor, devolvemos '‚Äî'.
 * - Si el Date() falla, devolvemos string original.
 */
const fechaHoraAR = (iso?: string | null) => {
  if (!iso) return '‚Äî';
  try {
    return new Date(iso).toLocaleString('es-AR', { hour12: false });
  } catch {
    return iso;
  }
};

/**
 * getAutorNombre(autor):
 * - Recibe la relaci√≥n "autor" del comentario.
 * - Esa relaci√≥n a veces llega como objeto √∫nico, a veces como [obj].
 * - Devuelve "Nombre Apellido" ya armado, o '‚Äî' si falta info.
 */
const getAutorNombre = (autor: any): string => {
  const a = Array.isArray(autor) ? autor[0] : autor;
  if (!a) return '‚Äî';
  const nom = (a?.nombre ?? '').toString();
  const ape = (a?.apellido ?? '').toString();
  return `${nom} ${ape}`.trim() || '‚Äî';
};

/**
 * getClienteNombre(cli):
 * - Igual que arriba: join puede venir como objeto o como [obj].
 * - Devuelve el nombre comercial/etiqueta del cliente (string) si existe,
 *   o null si no.
 */
const getClienteNombre = (cli: any): string | null => {
  const c = Array.isArray(cli) ? cli[0] : cli;
  if (!c) return null;
  const nombre = (c?.cliente ?? '').toString().trim();
  return nombre || null;
};
---

<BasePrivateLayout>
  <div class="container mt-4">
    {/* ============================================================
        4Ô∏è‚É£ Cabecera de la p√°gina
        - Muestra el nro de ticket (#ticket si est√°; si no, cae en id)
        - Muestra el nombre del cliente (si est√° disponible)
        - Bot√≥n para volver al detalle del ticket
        ============================================================ */}
    <div class="d-flex align-items-center justify-content-between mb-3">
      <h1 class="h5 mb-0">
        {/* Preferimos el n√∫mero de ticket "humano" (#1234).
           Si no est√°, usamos el id interno. */}
        Comentarios del Ticket #{ticket?.ticket ?? ticket?.id ?? id}
        {getClienteNombre(ticket?.cliente) && (
          <small class="text-muted">
            {' '}‚Äî {getClienteNombre(ticket?.cliente)}
          </small>
        )}
      </h1>

      {/* Bot√≥n Volver al detalle del ticket */}
      <a href={`/detalle/${id}`} class="btn btn-outline-secondary">
        <i class="bi bi-arrow-left"></i> Volver al detalle
      </a>
    </div>

    {/* ============================================================
        5Ô∏è‚É£ Card principal
        - Header: t√≠tulo "Historial" + contador total
        - Body:
          * formulario para agregar comentario (solo admin/t√©cnico)
          * lista de comentarios
          * placeholder "no hay comentarios" si est√° vac√≠o
        ============================================================ */}
    <div class="card shadow-sm">
      <div class="card-header bg-white d-flex align-items-center justify-content-between">
        <div>
          <strong>Historial</strong>
          {/* Contador total de comentarios.
             Se actualiza en vivo cuando agregamos uno nuevo en el front. */}
          <span class="text-muted">
            (<span id="comentarios-count">{totalComentarios ?? 0}</span>)
          </span>
        </div>
        {(isAdmin || isTecnico) && <span class="text-muted small"></span>}
      </div>

      <div class="card-body">
        {/* --------------------------------------------------------
            5.1 Formulario para agregar comentario
            - Solo visible si el usuario es admin o t√©cnico
            - Usa fetch POST + UI optimista (sin recargar)
            -------------------------------------------------------- */}
        {(isAdmin || isTecnico) && (
          <form
            id="form-comentario"
            class="mb-3"
            data-ticketid={id}
          >
            <div class="input-group">
              <textarea
                class="form-control"
                id="comentario-texto"
                placeholder="Agregar comentario (p. ej. 'Revisar extrusor')"
                rows="2"
                maxlength="2000"
                required
              ></textarea>
              <button class="btn btn-primary" type="submit">
                <i class="bi bi-send"></i> Agregar
              </button>
            </div>
            <div class="form-text">
              No se puede editar ni borrar.
            </div>
          </form>
        )}

        {/* --------------------------------------------------------
            5.2 Lista de comentarios
            - Siempre renderizamos la <ul>, aunque est√© vac√≠a,
              porque el script de abajo inserta <li> din√°micamente.
            - Cada comentario:
                ‚Ä¢ Muestra autor y fecha en gris
                ‚Ä¢ Muestra el mensaje
              IMPORTANTE:
              - Usamos set:html en el render SSR para comentarios YA VENIDOS de BD,
                porque comentarios autom√°ticos del sistema pueden tener <strong>, etc.
              - Para comentarios agregados desde el cliente (optimistic UI),
                el script inyecta texto con textContent para evitar XSS del usuario.
            -------------------------------------------------------- */}
        <ul class="list-group" id="comentarios-lista">
          {Array.isArray(comentarios) && comentarios.length > 0 && comentarios.map((c) => (
            <li class="list-group-item">
              {/* Encabezado del comentario: autor y fecha */}
              <div class="small text-muted">
                <strong>{getAutorNombre(c.autor)}</strong>
                {' '}¬∑ {fechaHoraAR(c.creado_en)}
              </div>

              {/* Contenido del comentario:
                 className .comentario -> CSS con white-space: pre-wrap
                 para preservar saltos de l√≠nea.
                 Usamos set:html ac√° porque viene de la base (trusted server-side). */}
              <div class="comentario" set:html={c.mensaje}></div>
            </li>
          ))}
        </ul>

        {/* --------------------------------------------------------
            5.3 Placeholder "No hay comentarios"
            - Visible solo si todav√≠a no hay ninguno.
            - El JS lo oculta cuando agregamos el primero.
            -------------------------------------------------------- */}
        <div
          id="no-comentarios"
          class="text-muted"
          style={{ display: (Array.isArray(comentarios) && comentarios.length > 0) ? 'none' : '' }}
        >
          No hay comentarios todav√≠a.
        </div>
      </div>
    </div>
  </div>

  {/* ============================================================
      6Ô∏è‚É£ Script de la p√°gina
      - Maneja el env√≠o del formulario sin recargar.
      - Hace POST a /api/agregarComentario.
      - Inserta el nuevo comentario al principio de la lista (optimistic UI).
      - Incrementa el contador.
      ============================================================ */}
  <script>
    // IIFE para aislar variables y no ensuciar el global
    (function(){
      // Referencias al form y a los elementos que vamos a manipular
      const form = document.getElementById('form-comentario') as HTMLFormElement | null;
      if (!form) return; // Si no hay form, el usuario no puede comentar (sin permisos)

      const textarea = document.getElementById('comentario-texto') as HTMLTextAreaElement | null;
      const lista = document.getElementById('comentarios-lista') as HTMLUListElement | null;
      const noMsg = document.getElementById('no-comentarios') as HTMLDivElement | null;
      const countEl = document.getElementById('comentarios-count') as HTMLSpanElement | null;

      // Guardamos el ticketId en data-ticketid del form para no depender de parsear la URL
      const ticketId = form.dataset.ticketid ? Number(form.dataset.ticketid) : null;

      form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const btn = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;

        // Leemos el mensaje tipeado por el usuario
        const mensaje = (textarea?.value || '').trim();
        if (!mensaje || !Number.isFinite(ticketId)) return;

        // Evitar doble submit spameando el bot√≥n
        if (btn) btn.disabled = true;

        try {
          // Hacemos POST al endpoint del backend que inserta el comentario en la BD
          const res = await fetch('/api/agregarComentario', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ticketId, mensaje })
          });

          const data = await res.json();

          if (!res.ok) {
            // Si la API devolvi√≥ error (403, 400, etc.) lo mostramos
            alert(data?.error || 'No se pudo agregar el comentario.');
            return;
          }

          // Si llegamos ac√°, el comentario qued√≥ registrado en el servidor.
          // Ahora actualizamos la UI en vivo (optimistic update).

          // 1. Ocultar "No hay comentarios todav√≠a", si estaba visible
          if (noMsg && noMsg.style.display !== 'none') {
            noMsg.style.display = 'none';
          }

          // 2. Construir un <li> "nuevo comentario" y ponerlo primero en la lista
          if (lista) {
            const li = document.createElement('li');
            li.className = 'list-group-item';

            // Fecha legible:
            // - Si la API devolvi√≥ `creado_en_humano` lo usamos
            // - Caso contrario, usamos la hora local actual
            const fechaHumana =
              data?.creado_en_humano ||
              new Date().toLocaleString('es-AR', { hour12: false });

            // Autor:
            // - Si la API devuelve el nombre del autor, lo usamos
            // - Si no, mostramos "Vos"
            const autor = data?.autor || 'Vos';

            // Usamos textContent para el mensaje del usuario actual
            // en vez de innerHTML para evitar inyectar HTML raro del lado cliente.
            li.innerHTML = `
              <div class="small text-muted">
                <strong></strong> ¬∑ <span class="fecha"></span>
              </div>
              <!-- üîπ Aca tambi√©n usamos .comentario para preservar saltos -->
              <div class="mensaje comentario"></div>
            `;
            (li.querySelector('strong') as HTMLElement).textContent = autor;
            (li.querySelector('.fecha') as HTMLElement).textContent = fechaHumana;
            (li.querySelector('.mensaje') as HTMLElement).textContent = mensaje;

            // Insertar al principio de la lista
            if (lista.firstChild) {
              lista.insertBefore(li, lista.firstChild);
            } else {
              lista.appendChild(li);
            }
          }

          // 3. Limpiar el textarea y devolver el foco
          if (textarea) {
            textarea.value = '';
            textarea.focus();
          }

          // 4. Incrementar contador visible
          if (countEl) {
            const n = parseInt(countEl.textContent || '0', 10) || 0;
            countEl.textContent = String(n + 1);
          }

        } catch (err) {
          // Cualquier error de red / fetch
          alert('Error de red: ' + (err && (err as any).message ? (err as any).message : String(err)));
        } finally {
          // Re-habilitar el bot√≥n Submit
          if (btn) btn.disabled = false;
        }
      });
    })();
  </script>
</BasePrivateLayout>

<style>
  /* ==================================================================
     7Ô∏è‚É£ Estilos locales
     - .comentario usa white-space: pre-wrap para mantener saltos de l√≠nea
       y espacios m√∫ltiples tal como los tipe√≥ el usuario o gener√≥ el sistema.
     ================================================================== */
  .comentario {
    white-space: pre-wrap;
  }
</style>
