---
/**
 * P√°gina de comentarios de un ticket.
 * - Muestra cabecera con nro de ticket y cliente.
 * - Lista los comentarios (√∫ltimos primero).
 * - Si el usuario es admin o t√©cnico, permite agregar comentarios v√≠a fetch
 *   con UI optimista, sin recargar la p√°gina.
 */
import BasePrivateLayout from '../../layouts/BasePrivateLayout.astro';
import { supabase } from '../../lib/supabase';

// Tomamos el :id de la URL din√°mica (p. ej. /comentarios/123)
const { id } = Astro.params as { id: string };

// Perfil/rol del usuario logueado (inyectado en Astro.locals por tu middleware)
type Perfil = { rol?: string; admin?: boolean; activo?: boolean };
const perfil = (Astro.locals as any).perfil as Perfil | undefined;
const isAdmin = (perfil?.rol === 'admin') || (perfil?.admin === true);
const isTecnico = perfil?.rol === 'tecnico';

// ================== Fetch de datos para render ==================

// 1) Traemos datos m√≠nimos del ticket para cabecera (n√∫mero, estado, y nombre del cliente)
const { data: ticket } = await supabase
  .from('tickets_mian')
  .select(`
    id, ticket, estado,
    cliente:cliente_id ( cliente )
  `)
  .eq('id', id)
  .maybeSingle();

// 2) Traemos los comentarios del ticket (ordenados descendente por fecha de creaci√≥n).
//    Tambi√©n pedimos el count exacto para mostrar el total.
const { data: comentarios, count: totalComentarios } = await supabase
  .from('ticket_comentarios')
  .select(`
    id,
    mensaje,
    creado_en,
    autor:autor_id ( nombre, apellido )
  `, { count: 'exact' })
  .eq('ticket_id', id)
  .order('creado_en', { ascending: false });

// ================== Helpers de presentaci√≥n ==================

/** Convierte ISO ‚Üí fecha/hora local de AR o devuelve '‚Äî' si no hay valor. */
const fechaHoraAR = (iso?: string | null) => {
  if (!iso) return '‚Äî';
  try { return new Date(iso).toLocaleString('es-AR', { hour12: false }); }
  catch { return iso; }
};

/** Devuelve "Nombre Apellido" del autor (con tolerancia a join como array). */
const getAutorNombre = (autor: any): string => {
  const a = Array.isArray(autor) ? autor[0] : autor;
  if (!a) return '‚Äî';
  const nom = (a?.nombre ?? '').toString();
  const ape = (a?.apellido ?? '').toString();
  return `${nom} ${ape}`.trim() || '‚Äî';
};

/** Obtiene el nombre completo del cliente (string) desde el join o null si no hay. */
const getClienteNombre = (cli: any): string | null => {
  const c = Array.isArray(cli) ? cli[0] : cli;
  if (!c) return null;
  const nombre = (c?.cliente ?? '').toString().trim();
  return nombre || null;
};
---

<BasePrivateLayout>
  <div class="container mt-4">
    <!-- Cabecera: t√≠tulo + bot√≥n volver -->
    <div class="d-flex align-items-center justify-content-between mb-3">
      <h1 class="h5 mb-0">
        <!-- Preferimos mostrar #ticket; si no, cae en id de la fila -->
        Comentarios del Ticket #{ticket?.ticket ?? ticket?.id ?? id}
        {getClienteNombre(ticket?.cliente) && (
          <small class="text-muted"> ‚Äî {getClienteNombre(ticket?.cliente)}</small>
        )}
      </h1>

      <a href={`/detalle/${id}`} class="btn btn-outline-secondary">
        <i class="bi bi-arrow-left"></i> Volver al detalle
      </a>
    </div>

    <!-- Tarjeta principal con historial y formulario -->
    <div class="card shadow-sm">
      <div class="card-header bg-white d-flex align-items-center justify-content-between">
        <div>
          <strong>Historial</strong>
          <!-- Contador total de comentarios (se actualiza en vivo al agregar) -->
          <span class="text-muted">(<span id="comentarios-count">{totalComentarios ?? 0}</span>)</span>
        </div>
        {(isAdmin || isTecnico) && <span class="text-muted small"></span>}
      </div>

      <div class="card-body">
        {/* Formulario para agregar comentario:
            - Solo visible para admin o t√©cnico
            - Usa fetch + UI optimista para insertar sin recargar */}
        {(isAdmin || isTecnico) && (
          <form id="form-comentario" class="mb-3" data-ticketid={id}>
            <div class="input-group">
              <textarea
                class="form-control"
                id="comentario-texto"
                placeholder="Agregar comentario (p. ej. 'Revisar extrusor')"
                rows="2"
                maxlength="2000"
                required
              ></textarea>
              <button class="btn btn-primary" type="submit">
                <i class="bi bi-send"></i> Agregar
              </button>
            </div>
            <div class="form-text">No se puede editar ni borrar.</div>
          </form>
        )}

        <!-- Lista de comentarios. La UL se renderiza siempre (aunque est√© vac√≠a)
             para que el JS pueda insertar elementos din√°micamente. -->
        <ul class="list-group" id="comentarios-lista">
          {Array.isArray(comentarios) && comentarios.length > 0 && comentarios.map((c) => (
            <li class="list-group-item">
              <!-- Encabezado del comentario: autor y fecha -->
              <div class="small text-muted">
                <strong>{getAutorNombre(c.autor)}</strong>
                ¬∑ {fechaHoraAR(c.creado_en)}
              </div>
              <!-- Contenido del comentario:
                   Usamos set:html porque los comentarios de sistema incluyen <strong>, vi√±etas, etc.
                   La clase .comentario aplica 'white-space: pre-wrap' via CSS para respetar saltos de l√≠nea. -->
              <div class="comentario" set:html={c.mensaje}></div>
            </li>
          ))}
        </ul>

        {/* Mensaje ‚Äúno hay comentarios‚Äù: lo oculta el JS cuando se crea el primero */}
        <div
          id="no-comentarios"
          class="text-muted"
          style={{ display: (Array.isArray(comentarios) && comentarios.length > 0) ? 'none' : '' }}
        >
          No hay comentarios todav√≠a.
        </div>
      </div>
    </div>
  </div>

  <!-- Script de la p√°gina: maneja el env√≠o del formulario y la UI optimista -->
  <script>
    // Alta de comentario con Optimistic UI (sin recargar)
    (function(){
      const form = document.getElementById('form-comentario') as HTMLFormElement | null;
      if (!form) return; // Si no hay form (usuario sin permisos), no hacemos nada.

      const textarea = document.getElementById('comentario-texto') as HTMLTextAreaElement | null;
      const lista = document.getElementById('comentarios-lista') as HTMLUListElement | null;
      const noMsg = document.getElementById('no-comentarios') as HTMLDivElement | null;
      const countEl = document.getElementById('comentarios-count') as HTMLSpanElement | null;

      // El ticketId viaja en un data-attribute del form para evitar leer desde la URL
      const ticketId = form.dataset.ticketid ? Number(form.dataset.ticketid) : null;

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const btn = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;

        const mensaje = (textarea?.value || '').trim();
        if (!mensaje || !Number.isFinite(ticketId)) return;

        if (btn) btn.disabled = true; // evita doble env√≠o

        try {
          // POST al endpoint de API que inserta el comentario en BD
          const res = await fetch('/api/agregarComentario', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ticketId, mensaje })
          });

          const data = await res.json();

          if (!res.ok) {
            // Si la API devolvi√≥ error, lo mostramos y cortamos
            alert(data?.error || 'No se pudo agregar el comentario.');
            return;
          }

          // Ocultamos mensaje de ‚Äúno hay comentarios‚Äù
          if (noMsg && noMsg.style.display !== 'none') noMsg.style.display = 'none';

          // Creamos un <li> y lo insertamos al principio de la lista (optimista)
          if (lista) {
            const li = document.createElement('li');
            li.className = 'list-group-item';
            const fechaHumana = data?.creado_en_humano || new Date().toLocaleString('es-AR', { hour12: false });
            const autor = data?.autor || 'Vos';

            li.innerHTML = `
              <div class="small text-muted">
                <strong></strong> ¬∑ <span class="fecha"></span>
              </div>
              <!-- üîπ Aca tambi√©n la clase para respetar saltos -->
              <div class="mensaje comentario"></div>
            `;
            (li.querySelector('strong') as HTMLElement).textContent = autor;
            (li.querySelector('.fecha') as HTMLElement).textContent = fechaHumana;
            // Para el comentario del usuario usamos textContent (no HTML) para evitar XSS desde la UI
            (li.querySelector('.mensaje') as HTMLElement).textContent = mensaje;

            if (lista.firstChild) lista.insertBefore(li, lista.firstChild);
            else lista.appendChild(li);
          }

          // Limpiar textarea y actualizar contador
          if (textarea) {
            textarea.value = '';
            textarea.focus();
          }
          if (countEl) {
            const n = parseInt(countEl.textContent || '0', 10) || 0;
            countEl.textContent = String(n + 1);
          }

        } catch (err) {
          alert('Error de red: ' + (err && (err as any).message ? (err as any).message : String(err)));
        } finally {
          if (btn) btn.disabled = false;
        }
      });
    })();
  </script>
</BasePrivateLayout>

<style>
  /* Asegura que los saltos de l√≠nea (\n) se vean correctamente en mensajes largos. */
  .comentario {
    white-space: pre-wrap;
  }
</style>
