---
/**
 * P√°gina /delivery/:id
 *
 * üöö Prop√≥sito:
 * - Pantalla para cargar o editar la info de Delivery asociada a un ticket.
 * - Renderiza un formulario (<DeliveryForm />) ya precompletado con la mejor info disponible.
 *
 * üíæ De d√≥nde salen los datos que prellenan el form:
 *   1. √öltimo registro guardado en la tabla `delivery` para este ticket.
 *   2. Datos del cliente asociado al ticket (direcci√≥n, localidad, info adicional).
 *   3. Par√°metros en la URL (?cotizar_delivery=... etc.) usados como precarga manual.
 *
 *   Prioridad final (de mayor a menor):
 *     delivery > cliente > precarga
 *
 *   Ejemplo:
 *   - Si ya hay `delivery.localidad`, usamos esa.
 *   - Si no, usamos `cliente.localidad`.
 *   - Si tampoco hay, usamos `precarga.localidad` (si vino en querystring).
 *
 * üìã Qu√© mostramos:
 * - T√≠tulo con √≠cono de cami√≥n.
 * - Si el ticket existe ‚Üí <DeliveryForm equipo={...} />
 * - Si NO existe ‚Üí alerta de error.
 *
 * üîê Auth/permisos:
 * - Esta vista asume que solo usuarios v√°lidos llegan ac√°
 *   (middleware debe filtrar antes). No se hace check directo ac√°.
 */

import BasePrivateLayout from '../../layouts/BasePrivateLayout.astro';
import DeliveryForm from '../../components/DeliveryForm.astro';
import { supabase } from '../../lib/supabase';

// ======================================================================
// 1Ô∏è‚É£ Leer datos iniciales del request
// ======================================================================

// Obtenemos la URL actual para leer los query params usados como precarga.
// Ej: /delivery/123?cotizar_delivery=si&pagado=true
const url = new URL(Astro.request.url);

/**
 * precarga:
 * - Datos opcionales que pueden venir por querystring para precompletar el formulario.
 * - Usamos `?? undefined` en cada campo:
 *     - Si el query param NO est√°, guardamos undefined (NO string "null" ni "").
 *     - Esto nos permite luego hacer el merge sin pisar valores reales con undefined.
 *
 * Notas:
 * - fecha_de_entrega est√° incluida aunque del lado backend quiz√° no se use todav√≠a,
 *   pero la UI puede querer mostrarla.
 */
const precarga = {
  cotizar_delivery: url.searchParams.get('cotizar_delivery') ?? undefined,
  informacion_adicional_delivery: url.searchParams.get('informacion_adicional_delivery') ?? undefined,
  medio_de_entrega: url.searchParams.get('medio_de_entrega') ?? undefined,
  fecha_de_entrega: url.searchParams.get('fecha_de_entrega') ?? undefined,
  forma_de_pago: url.searchParams.get('forma_de_pago') ?? undefined,
  pagado: url.searchParams.get('pagado') ?? undefined,
  direccion: url.searchParams.get('direccion') ?? undefined,
  localidad: url.searchParams.get('localidad') ?? undefined,
};

// Tomamos el par√°metro din√°mico :id de la ruta (/delivery/:id)
const { id } = Astro.params as { id: string };

// ======================================================================
// 2Ô∏è‚É£ Buscar datos del ticket y del cliente relacionado
// ======================================================================
//
// Traemos de `tickets_mian`:
//   - id               (PK interna del ticket)
//   - ticket           (n√∫mero "visible" del ticket)
//   - cliente_id       (FK)
//   - cliente:*        (join a la tabla cliente para direcci√≥n/contacto)
//
// cliente:cliente_id (...) hace el join y lo expone como `ticket.cliente`.
const { data: ticket } = await supabase
  .from('tickets_mian')
  .select(`
    id,
    ticket,
    cliente_id,
    cliente:cliente_id (
      cliente,
      direccion,
      localidad,
      informacion_adicional_usuario
    )
  `)
  .eq('id', id)
  .single();

// ======================================================================
// 3Ô∏è‚É£ Buscar el √∫ltimo registro de delivery guardado para el ticket
// ======================================================================
//
// Puede haber m√∫ltiples registros en la tabla `delivery` para el mismo ticket.
// Tomamos el m√°s reciente ordenando por id DESC y qued√°ndonos con el primero.
const { data: deliveryRows } = await supabase
  .from('delivery')
  .select('*')
  .eq('ticket_id', id)
  .order('id', { ascending: false })
  .limit(1);

const delivery = Array.isArray(deliveryRows) ? deliveryRows[0] : null;

// ======================================================================
// 4Ô∏è‚É£ Armar el objeto `equipo` que va al <DeliveryForm />
// ======================================================================
//
// Objetivo: darle al formulario un √∫nico objeto con la info consolidada.
//
// Estructura final `equipo` incluye:
//   - ticketId          ‚Üí id interno del ticket
//   - ticketNumero      ‚Üí nro "humano" (ticket.ticket)
//   - todos los campos previos de delivery (si existen)
//   - direccion / localidad / informacion_adicional_delivery resueltos con prioridad
//   - TODOS los campos que llegaron por precarga (excepto los undefined)
//
// Reglas de prioridad para direccion / localidad / informacion_adicional_delivery:
//   delivery > cliente > precarga
//
// Nota importante:
//   Hacemos el spread de `delivery` primero y luego sobreescribimos campos
//   espec√≠ficos con merge manual usando ?? para mantener esa prioridad.
//
//   Al final, hacemos merge con `precarga`, pero OJO:
//   - filtramos precarga para excluir keys cuyo valor sea undefined.
//     Esto evita que un undefined de la URL tape un valor real existente.
//
const equipo = {
  ticketId: ticket?.id,
  ticketNumero: ticket?.ticket,

  // Todos los campos existentes en delivery (pueden incluir: forma_de_pago, pagado, etc.)
  ...delivery,

  // Campos con prioridad expl√≠cita delivery > cliente > (luego precarga m√°s abajo):
  direccion:
    (delivery as any)?.direccion ??
    (ticket as any)?.cliente?.direccion ??
    undefined,

  localidad:
    (delivery as any)?.localidad ??
    (ticket as any)?.cliente?.localidad ??
    undefined,

  informacion_adicional_delivery:
    (delivery as any)?.informacion_adicional_delivery ??
    (ticket as any)?.cliente?.informacion_adicional_usuario ??
    undefined,

  // Por √∫ltimo, mergeamos la precarga SIN las props undefined.
  // Ejemplo: si la URL trae ?pagado=true, lo agregamos ac√°.
  // Si la precarga tiene algo undefined, lo descartamos.
  ...Object.fromEntries(
    Object.entries(precarga).filter(([_, v]) => v !== undefined)
  ),
};
---

<BasePrivateLayout>
  <div class="container mt-5">
    <h2 class="mb-4">
      <i class="bi bi-truck me-2"></i>
      A√±adir delivery
    </h2>

    {
      /**
       * Render principal:
       *
       * ‚úî Si existe el ticket ‚Üí mostramos el formulario DeliveryForm con los datos consolidados.
       *   - <DeliveryForm equipo={equipo} />
       *     donde `equipo` ya trae ticketId, direcci√≥n, localidad, etc.
       *
       * ‚úñ Si NO hay ticket (ticketId falsy) ‚Üí mostramos alerta de error.
       *   Esto cubre casos de /delivery/:id inexistente o consultas rotas.
       */
      equipo?.ticketId
        ? <DeliveryForm equipo={equipo} />
        : <div class="alert alert-danger">
            No se encontr√≥ el ticket con ID: {id}
          </div>
    }
  </div>
</BasePrivateLayout>
