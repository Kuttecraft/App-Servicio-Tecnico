---
/**
 * Dashboard (listado principal de tickets)
 *
 * üéØ Objetivo:
 * - Mostrar una cuadr√≠cula de tickets (cada uno en una <PrinterCard /> compacta).
 * - Permitir filtrar y paginar resultados.
 * - Los filtros se controlan desde un Topbar con un form que arma la querystring (?by=...&q=...).
 *
 * Campos t√≠picos mostrados en cada tarjeta:
 * - N¬∞ ticket
 * - Cliente
 * - Modelo/m√°quina
 * - Estado actual
 * - WhatsApp del cliente (para contacto r√°pido)
 * - Imagen miniatura de la impresora
 *
 * üîé Filtros soportados (`by` + `q`):
 *   by = "id"       ‚Üí busca por tickets_mian.id exacto
 *   by = "ticket"   ‚Üí busca por tickets_mian.ticket exacto
 *   by = "estado"   ‚Üí igualdad exacta con estado
 *   by = "cliente"  ‚Üí ilike sobre cliente.cliente (nombre del cliente)
 *   by = "maquina"  ‚Üí ilike sobre impresora.modelo
 *
 * Importante:
 *   - Para filtros por cliente/maquina usamos `!inner` en el SELECT de Supabase
 *     para forzar INNER JOIN y filtrar s√≥lo los que realmente tienen esa relaci√≥n
 *     (sin traer filas hu√©rfanas).
 *
 * üìÑ Paginaci√≥n:
 *   - Paginaci√≥n server-side usando .range(from, to)
 *   - itemsPerPage = 500 para minimizar la paginaci√≥n manual (pensado para cat√°logos medianos)
 *   - currentPage viene de ?page=#
 *
 * üîê Layout:
 *   - Usa <BasePrivateLayout showFilters={true} />
 *   - Se asume que el middleware ya valid√≥ sesi√≥n y que el Topbar inyecta los controles de filtro.
 */

import BasePrivateLayout from '../layouts/BasePrivateLayout.astro';
import PrinterCard from '../components/PrinterCard.astro';
import { supabase } from '../lib/supabase';

// =================== FILTROS (desde querystring) ===================
//
// `by` define qu√© columna/relaci√≥n se filtra.
// `q` es el valor buscado.
// Ambos los provee el <Topbar /> (o quien sea que genere la barra de filtros).
//
// Ejemplos de URL:
//   /dashboard?by=cliente&q=juan
//   /dashboard?by=maquina&q=Ender
//   /dashboard?by=estado&q=Lista
//
const by = Astro.url.searchParams.get('by') || 'id';
const rawQ = Astro.url.searchParams.get('q') || '';
const q = rawQ.trim(); // saneado b√°sico

// =================== PAGINACI√ìN ===================
//
// currentPage: viene de ?page=, default 1
// itemsPerPage: tama√±o de p√°gina muy grande (500) para reducir el click "Siguiente"
// from / to: √≠ndices que usaremos en .range(from, to) de Supabase.
//
const pageParam = Astro.url.searchParams.get('page') || '1';
const currentPage = parseInt(pageParam);
const itemsPerPage = 500;

const from = (currentPage - 1) * itemsPerPage;
const to = from + itemsPerPage - 1;

// =================== SELECT BASE ===================
//
// Supabase permite aliasar las relaciones as√≠:
//
//   impresora:impresoras (modelo)
//   cliente:cliente (cliente, whatsapp)
//
// Eso construye en cada fila devuelta un objeto:
//   { impresora: { modelo }, cliente: { cliente, whatsapp } }
//
// NOTA SOBRE !inner:
//   - Si agreg√°s !inner en una relaci√≥n, Supabase hace INNER JOIN en esa relaci√≥n.
//   - Lo usamos cuando necesitamos filtrar por un campo de esa relaci√≥n:
//       * Filtrar por cliente -> necesitamos cliente s√≠ o s√≠ -> cliente!inner
//       * Filtrar por maquina -> necesitamos impresoras s√≠ o s√≠ -> impresoras!inner
//
// Si no ponemos !inner, es b√°sicamente LEFT JOIN: podemos tener filas sin cliente/impresora
// sin que se "caigan" del resultado.
//
let selectStr = `
  id,
  ticket,
  estado,
  imagen,
  impresora:impresoras (modelo),
  cliente:cliente (cliente, whatsapp)
`;

// Caso especial 1: filtro por cliente
// Al filtrar por cliente, queremos asegurar que el join cliente exista
// porque vamos a hacer ilike sobre cliente.cliente.
// Por eso forzamos cliente!inner para convertirlo en INNER JOIN.
if (by === 'cliente') {
  selectStr = `
    id,
    ticket,
    estado,
    imagen,
    impresora:impresoras (modelo),
    cliente:cliente!inner (cliente, whatsapp)
  `;
}

// Caso especial 2: filtro por m√°quina
// Idem cliente, pero con impresoras. Hacemos impresoras!inner para garantizar
// que haya una impresora asociada y poder ilikear impresora.modelo.
if (by === 'maquina') {
  selectStr = `
    id,
    ticket,
    estado,
    imagen,
    impresora:impresoras!inner (modelo),
    cliente:cliente (cliente, whatsapp)
  `;
}

// =================== CONSTRUCCI√ìN DE LA QUERY ===================
//
// Empezamos con .from('tickets_mian').select(selectStr).
// Despu√©s aplicamos where/ilike seg√∫n `by`.
// Finalmente ordenamos y aplicamos .range() para la paginaci√≥n.
//
let query = supabase
  .from('tickets_mian')
  .select(selectStr);

// =================== APLICACI√ìN DE FILTROS ===================
//
// REGLA GENERAL:
// - Si q est√° vac√≠o ‚Üí no filtramos (salvo el caso 'estado' si quisieras default, pero ac√° no).
// - Si q tiene contenido:
//     by = id/ticket ‚Üí forzamos igualdad exacta num√©rica.
//     by = estado    ‚Üí igualdad exacta string.
//     by = cliente   ‚Üí ilike en cliente.cliente (usa !inner).
//     by = maquina   ‚Üí ilike en impresora.modelo (usa !inner).
//
// ILUSTRACI√ìN DE CASOS:
//   by="id"     q="123"  ‚Üí eq('id',123)
//   by="ticket" q="456"  ‚Üí eq('ticket',456)
//   by="estado" q="Lista" ‚Üí eq('estado','Lista')
//   by="cliente" q="juan" ‚Üí ilike('cliente.cliente','%juan%')
//   by="maquina" q="Ender" ‚Üí ilike('impresora.modelo','%Ender%')
//
// Nota sutil: para id/ticket asumimos b√∫squeda EXACTA por n√∫mero.
// Si el usuario escribe algo no-num√©rico, devolvemos un resultado imposible eq(-1)
// para no tirar todo el dataset entero.
//
if (q) {
  // Si q parsea a n√∫mero, qNum es ese n√∫mero;
  // si no, qNum = null (para detectar casos inv√°lidos en id/ticket).
  const qNum = Number.isFinite(Number(q)) ? Number(q) : null;

  switch (by) {
    case 'id':
      // id es PK num√©rica del ticket
      query = qNum !== null
        ? query.eq('id', qNum)
        : query.eq('id', -1); // fuerza "sin resultados"
      break;

    case 'ticket':
      // ticket es el n√∫mero de ticket "visible" para el cliente
      query = qNum !== null
        ? query.eq('ticket', qNum)
        : query.eq('ticket', -1);
      break;

    case 'estado':
      // estado textual exacto
      query = query.eq('estado', q);
      break;

    case 'cliente':
      // cliente.cliente = nombre del cliente
      // usamos ilike para b√∫squeda parcial
      // requiere cliente!inner en selectStr
      query = query.ilike('cliente.cliente', `%${q}%`);
      break;

    case 'maquina':
      // impresora.modelo = modelo de la impresora
      // ilike parcial
      // requiere impresoras!inner en selectStr
      query = query.ilike('impresora.modelo', `%${q}%`);
      break;

    default:
      // Si llega un 'by' desconocido, no aplicamos filtro extra.
      break;
  }
}

// =================== ORDEN + RANGO ===================
//
// Mostramos primero los tickets m√°s recientes (id DESC).
// Luego limitamos el resultado con .range(from, to) para la p√°gina actual.
//
query = query
  .order('id', { ascending: false })
  .range(from, to);

// =================== EJECUCI√ìN ===================
//
// Disparamos la query construida arriba.
// `error` puede existir si Supabase falla.
// `data` es la lista de tickets final para esta p√°gina.
//
const { data, error } = await query;

// Blindaje final: siempre queremos que `impresoras` sea un array iterable
// para el mapeo en el template, aunque la query falle.
const impresoras = Array.isArray(data) ? data : [];
if (error) {
  console.error('Error supabase:', error, { by, q });
}
---

<BasePrivateLayout showFilters={true}>
  <div class="container mt-4">

    {/* =================== LISTA DE RESULTADOS ===================
        - Si hay resultados, renderizamos un grid Bootstrap.
        - Cada ticket se pinta con <PrinterCard />, que recibe:
            id, ticket, cliente, maquina, estado, whatsapp, imagen,
            y URLs para navegar al detalle (/detalle/:id) y edici√≥n (/editar/:id).
        - Si no hay resultados o hubo error, mostramos un mensaje.
    */}
    {Array.isArray(impresoras) && impresoras.length > 0 ? (
      <div class="row g-4">
        {impresoras.map((item: any) => (
          <div class="col-sm-6 col-md-4 col-lg-3">
            <PrinterCard
              id={item.id}
              ticket={item.ticket || 'Sin ticket'}
              cliente={item.cliente?.cliente || 'Desconocido'}
              maquina={item.impresora?.modelo || 'Desconocido'}
              estado={item.estado || 'Desconocido'}
              whatsapp={item.cliente?.whatsapp || 'No especificado'}
              imagen={item.imagen || null}
              onClickUrl={`/detalle/${item.id}`}
              onClickUrlEditar={`/editar/${item.id}`}
            />
          </div>
        ))}
      </div>
    ) : (
      <div class="text-center">
        <p class="text-muted">
          {error ? 'Error al cargar resultados' : 'No hay resultados.'}
        </p>
      </div>
    )}

    {/* =================== PAGINACI√ìN ===================
        - Botones "Anterior" y "Siguiente".
        - Construimos el href preservando `by` y `q`
          pero cambiando `page`.
        - Mostramos "P√°gina N".
        - Bot√≥n "Siguiente" s√≥lo si esta p√°gina est√° llena
          (== itemsPerPage). Eso implica que probablemente haya m√°s.
    */}
    <div class="d-flex justify-content-center mt-4 gap-2">
      {currentPage > 1 && (
        <a
          href={`?${new URLSearchParams({
            q,
            by,
            page: String(currentPage - 1)
          }).toString()}`}
          class="btn btn-outline-secondary"
        >
          Anterior
        </a>
      )}

      <span class="align-self-center">
        P√°gina {currentPage}
      </span>

      {Array.isArray(impresoras) && impresoras.length === itemsPerPage && (
        <a
          href={`?${new URLSearchParams({
            q,
            by,
            page: String(currentPage + 1)
          }).toString()}`}
          class="btn btn-outline-secondary"
        >
          Siguiente
        </a>
      )}
    </div>

  </div>
</BasePrivateLayout>
